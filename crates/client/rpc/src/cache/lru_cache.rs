use scale_codec::Encode;
use schnellru::{ByMemoryUsage, LruMap, Unlimited};

/// Structure used for caching over the RPC layer. It is heavily inspired from [frontier's
/// implementation](https://github.com/paritytech/frontier/blob/194f6bb06152402ba44b340c3d401ae6e0670d96/client/rpc/src/eth/cache/mod.rs#L76).
pub struct LRUCache<K, V> {
    /// Cache name.
    name: &'static str,
    /// Maximum allocated memory size.
    max_allocated_size: Option<usize>,
    /// Maximum values size.
    max_values_size: Option<usize>,
    /// Values current size.
    values_size: usize,
    /// Inner cache, with different variant from [`InnerCache`]
    inner: EnumInnerCache<K, V>,
    /// Metrics generated by our cache for prometheus.
    metrics: Option<LRUCacheByteLimitedMetrics>,
}

/// Enumeration containing the different variant of inner cache we can find in our LRU cache. As of
/// now solely used to restrict the allocated memory for the cache.
pub enum EnumInnerCache<K, V> {
    Unlimited(LruMap<K, V, Unlimited>),
    AllocatedMemoryRestricted(LruMap<K, V, ByMemoryUsage>),
}

impl<K: Eq + core::hash::Hash, V: Encode> EnumInnerCache<K, V> {
    pub fn get(&mut self, k: &K) -> Option<&mut V> {
        match self {
            EnumInnerCache::Unlimited(cache) => cache.get(k),
            EnumInnerCache::AllocatedMemoryRestricted(cache) => cache.get(k),
        }
    }

    pub fn insert(&mut self, k: K, v: V) -> bool {
        match self {
            EnumInnerCache::Unlimited(cache) => cache.insert(k, v),
            EnumInnerCache::AllocatedMemoryRestricted(cache) => cache.insert(k, v),
        }
    }

    pub fn pop_oldest(&mut self) -> Option<(K, V)> {
        match self {
            EnumInnerCache::Unlimited(cache) => cache.pop_oldest(),
            EnumInnerCache::AllocatedMemoryRestricted(cache) => cache.pop_oldest(),
        }
    }

    pub fn memory_usage(&self) -> usize {
        match self {
            EnumInnerCache::Unlimited(cache) => cache.memory_usage(),
            EnumInnerCache::AllocatedMemoryRestricted(cache) => cache.memory_usage(),
        }
    }
}

enum CacheAction {
    Hit,
    Miss,
    Insert,
}

impl<K: Eq + core::hash::Hash, V: Encode> LRUCache<K, V> {
    /// Instantiate a new cache with a give name and size limit. If a prometheus registry is passed,
    /// then we register our cache metrics.
    pub fn new(
        cache_name: &'static str,
        max_allocated_size: Option<usize>,
        max_values_size: Option<usize>,
        prometheus_registry: Option<prometheus_endpoint::Registry>,
    ) -> Self {
        // If a registry was provided, then register our cache metrics to it.
        let metrics = match prometheus_registry {
            Some(registry) => match LRUCacheByteLimitedMetrics::register(cache_name, &registry) {
                Ok(metrics) => Some(metrics),
                Err(e) => {
                    log::error!(target: cache_name, "Failed to register metrics: {:?}", e);
                    None
                }
            },
            None => None,
        };
        // Return new empty cache.
        Self {
            name: cache_name,
            inner: if let Some(max_allocated_size) = max_allocated_size {
                EnumInnerCache::AllocatedMemoryRestricted(LruMap::new(ByMemoryUsage::new(max_allocated_size)))
            } else {
                EnumInnerCache::Unlimited(LruMap::new(Unlimited))
            },
            max_allocated_size,
            max_values_size,
            values_size: 0,
            metrics,
        }
    }

    /// Try to retrieve a value at a given key from our cache. If metrics are active we update them
    /// accordingly.
    pub fn get(&mut self, k: &K) -> Option<&mut V> {
        let action = if self.inner.get(k).is_some() { CacheAction::Hit } else { CacheAction::Miss };
        self.update_metrics(action);
        self.inner.get(k)
    }

    /// Try to insert a new value at a given key in our cache. Also updates our metrics to the
    /// current cache size.
    pub fn insert(&mut self, k: K, v: V) -> bool {
        // Check against the max_values_size if it's set.
        if let Some(max_values) = self.max_values_size {
            if v.encoded_size() > max_values {
                log::warn!(target: self.name, "Entry size exceeds maximum allowed size");
                return false;
            }
        }

        let mut tmp_size = self.values_size + v.encoded_size();

        // Making space for our new value if needed
        if let Some(max_values) = self.max_values_size {
            while tmp_size > max_values {
                if let Some((_, evicted_value)) = self.inner.pop_oldest() {
                    tmp_size -= evicted_value.encoded_size();
                } else {
                    break;
                }
            }
        }

        self.values_size = tmp_size;

        // Try to insert the entry.
        if self.inner.insert(k, v) {
            self.update_metrics(CacheAction::Insert);
            true
        } else {
            log::warn!(target: self.name, "Failed to insert entry into cache");
            false
        }
    }

    /// Utility function to handle metrics update.
    fn update_metrics(&self, action: CacheAction) {
        if let Some(metrics) = &self.metrics {
            match action {
                CacheAction::Hit => metrics.hits.inc(),
                CacheAction::Miss => metrics.miss.inc(),
                CacheAction::Insert => {
                    metrics.values_size.set(self.values_size as u64);
                    metrics.allocated_memory_size.set(self.inner.memory_usage() as u64)
                }
            }
        }
    }
}

struct LRUCacheByteLimitedMetrics {
    hits: prometheus::IntCounter,
    miss: prometheus::IntCounter,
    allocated_memory_size: prometheus_endpoint::Gauge<prometheus_endpoint::U64>,
    values_size: prometheus_endpoint::Gauge<prometheus_endpoint::U64>,
}

impl LRUCacheByteLimitedMetrics {
    pub(crate) fn register(
        cache_name: &'static str,
        registry: &prometheus_endpoint::Registry,
    ) -> Result<Self, prometheus_endpoint::PrometheusError> {
        Ok(Self {
            hits: prometheus_endpoint::register(
                prometheus::IntCounter::new(
                    format!("madara_starknet_{}_hits", cache_name),
                    format!("Hits of starknet {} cache.", cache_name),
                )?,
                registry,
            )?,
            miss: prometheus_endpoint::register(
                prometheus::IntCounter::new(
                    format!("madara_starknet_{}_miss", cache_name),
                    format!("Misses of starknet {} cache.", cache_name),
                )?,
                registry,
            )?,
            allocated_memory_size: prometheus_endpoint::register(
                prometheus_endpoint::Gauge::new(
                    format!("madara_starknet_{}_size", cache_name),
                    format!("Allocated memory size of starknet {} data cache.", cache_name),
                )?,
                registry,
            )?,
            values_size: prometheus_endpoint::register(
                prometheus_endpoint::Gauge::new(
                    format!("madara_starknet_{}_size", cache_name),
                    format!("Total values size in starknet {} data cache.", cache_name),
                )?,
                registry,
            )?,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_failure_insert_over_allocated_limit() {
        let mut cache = LRUCache::new("name", Some(10), None, None);
        // Should fail as base memory allocation for a string is 148 bytes.
        assert!(!cache.insert(0, "abcdefghijkl"));
    }

    #[test]
    fn test_failure_insert_over_values_limit() {
        let mut cache = LRUCache::new("name", None, Some(10), None);
        // Should fail as value size is over 10 bytes.
        assert!(!cache.insert(0, "abcdefghijkl"));
    }

    #[test]
    fn test_work_values_size_limit() {
        let mut cache = LRUCache::new("name", None, Some(10), None);
        assert!(cache.insert(0, "abcd"));
        assert!(cache.get(&0).is_some());
        assert!(cache.insert(1, "efghij"));
        assert!(cache.get(&1).is_some());
        assert!(cache.insert(2, "k"));
        assert!(cache.get(&2).is_some());
        // Entry (0,  "abcd") should be deleted
        assert!(cache.get(&0).is_none());
        // Size should be 7 now, so we should be able to add a value of size 3
        assert!(cache.insert(3, "lmn"));
        assert!(cache.get(&3).is_some());
    }

    #[test]
    fn test_work_allocated_size_limit() {
        let mut cache = LRUCache::new("name", Some(150), None, None);
        // Allocated memory will keep being 148 bytes for the three first insert.
        assert!(cache.insert(1, "a"));
        let memory_usage_step_1 = cache.inner.memory_usage();
        assert!(cache.insert(2, "b"));
        assert!(cache.insert(3, "c"));
        // Memory allocation will try to reach 280 bytes, blocked by our limiter. Insertion should be
        // succesful but first item should be removed from cache.
        assert!(cache.insert(4, "d"));
        let memory_usage_step_2 = cache.inner.memory_usage();
        assert!(cache.get(&4).is_some());
        assert!(cache.get(&1).is_none());
        assert_eq!(memory_usage_step_1, memory_usage_step_2);
    }
}
