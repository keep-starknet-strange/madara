use scale_codec::Encode;
use schnellru::{ByMemoryUsage, LruMap};

/// Structure used for caching over the RPC layer. It is heavily inspired from [frontier's
/// implementation](https://github.com/paritytech/frontier/blob/194f6bb06152402ba44b340c3d401ae6e0670d96/client/rpc/src/eth/cache/mod.rs#L76).
pub struct LRUCache<K, V> {
    /// Cache name.
    name: &'static str,
    /// Inner cache, with different variant from [`InnerCache`]
    inner: LruMap<K, V, ByMemoryUsage>,
    /// Metrics generated by our cache for prometheus.
    metrics: Option<LRUCacheByteLimitedMetrics>,
}

enum CacheAction {
    Hit,
    Miss,
    Insert,
}

impl<K: Eq + core::hash::Hash, V: Encode> LRUCache<K, V> {
    /// Instantiate a new cache with a given name and size limit. If a prometheus registry is passed,
    /// then we register our cache metrics.
    pub fn new(
        cache_name: &'static str,
        max_allocated_size: usize,
        prometheus_registry: Option<prometheus_endpoint::Registry>,
    ) -> Self {
        // If a registry was provided, then register our cache metrics to it.
        let metrics = match prometheus_registry {
            Some(registry) => match LRUCacheByteLimitedMetrics::register(cache_name, &registry) {
                Ok(metrics) => Some(metrics),
                Err(e) => {
                    log::error!(target: cache_name, "Failed to register metrics: {:?}", e);
                    None
                }
            },
            None => None,
        };
        // Return new empty cache.
        Self { name: cache_name, inner: LruMap::new(ByMemoryUsage::new(max_allocated_size)), metrics }
    }

    /// Try to retrieve a value at a given key from our cache. If metrics are active we update them
    /// accordingly.
    pub fn get(&mut self, k: &K) -> Option<&mut V> {
        let action = if self.inner.get(k).is_some() { CacheAction::Hit } else { CacheAction::Miss };
        self.update_metrics(action);
        self.inner.get(k)
    }

    /// Try to insert a new value at a given key in our cache. Also updates our metrics to the
    /// current cache size.
    pub fn insert(&mut self, k: K, v: V) -> bool {
        // Try to insert the entry.
        if self.inner.insert(k, v) {
            self.update_metrics(CacheAction::Insert);
            true
        } else {
            log::warn!(target: self.name, "Failed to insert entry into cache");
            false
        }
    }

    /// Utility function to handle metrics update.
    fn update_metrics(&self, action: CacheAction) {
        if let Some(metrics) = &self.metrics {
            match action {
                CacheAction::Hit => metrics.hits.inc(),
                CacheAction::Miss => metrics.miss.inc(),
                CacheAction::Insert => metrics.allocated_memory_size.set(self.inner.memory_usage() as u64),
            }
        }
    }
}

struct LRUCacheByteLimitedMetrics {
    hits: prometheus::IntCounter,
    miss: prometheus::IntCounter,
    allocated_memory_size: prometheus_endpoint::Gauge<prometheus_endpoint::U64>,
}

impl LRUCacheByteLimitedMetrics {
    pub(crate) fn register(
        cache_name: &'static str,
        registry: &prometheus_endpoint::Registry,
    ) -> Result<Self, prometheus_endpoint::PrometheusError> {
        Ok(Self {
            hits: prometheus_endpoint::register(
                prometheus::IntCounter::new(
                    format!("madara_starknet_{}_hits", cache_name),
                    format!("Hits of starknet {} cache.", cache_name),
                )?,
                registry,
            )?,
            miss: prometheus_endpoint::register(
                prometheus::IntCounter::new(
                    format!("madara_starknet_{}_miss", cache_name),
                    format!("Misses of starknet {} cache.", cache_name),
                )?,
                registry,
            )?,
            allocated_memory_size: prometheus_endpoint::register(
                prometheus_endpoint::Gauge::new(
                    format!("madara_starknet_{}_size", cache_name),
                    format!("Allocated memory size of starknet {} data cache.", cache_name),
                )?,
                registry,
            )?,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_failure_insert_over_allocated_limit() {
        let mut cache = LRUCache::new("name", 10, None);
        // Should fail as base memory allocation for a string is 148 bytes.
        assert!(!cache.insert(0, "abcdefghijkl"));
    }

    #[test]
    fn test_work_allocated_size_limit() {
        let mut cache = LRUCache::new("name", 150, None);
        // Allocated memory will keep being 148 bytes for the three first insert.
        assert!(cache.insert(1, "a"));
        let memory_usage_step_1 = cache.inner.memory_usage();
        assert!(cache.insert(2, "b"));
        assert!(cache.insert(3, "c"));
        // Memory allocation will try to reach 280 bytes, blocked by our limiter. Insertion should be
        // succesful but first item should be removed from cache.
        assert!(cache.insert(4, "d"));
        let memory_usage_step_2 = cache.inner.memory_usage();
        assert!(cache.get(&4).is_some());
        assert!(cache.get(&1).is_none());
        assert_eq!(memory_usage_step_1, memory_usage_step_2);
    }
}
