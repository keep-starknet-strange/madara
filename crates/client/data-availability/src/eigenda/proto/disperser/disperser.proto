syntax = "proto3";

option go_package = "github.com/Layr-Labs/eigenda/api/grpc/disperser";
package disperser;

// Disperser defines the public APIs for dispersing blobs.
service Disperser {
	// This API accepts blob to disperse from clients.
	// This executes the dispersal async, i.e. it returns once the request
	// is accepted. The client could use GetBlobStatus() API to poll the the
	// processing status of the blob.
	rpc DisperseBlob(DisperseBlobRequest) returns (DisperseBlobReply) {}

	// This API is meant to be polled for the blob status.
	rpc GetBlobStatus(BlobStatusRequest) returns (BlobStatusReply) {}

	// This retrieves the requested blob from the Disperser's backend.
	// This is a more efficient way to retrieve blobs than directly retrieving
	// from the DA Nodes (see detail about this approach in
	// api/proto/retriever/retriever.proto).
	// The blob should have been initially dispersed via this Disperser service
	// for this API to work.
	rpc RetrieveBlob(RetrieveBlobRequest) returns (RetrieveBlobReply) {}
}

// Requests and Responses

message DisperseBlobRequest {
	// The data to be dispersed.
	// The size of data must be <= 512KiB.
	bytes data = 1;
	// Security parameters allowing clients to customize the safety (via adversary threshold)
	// and liveness (via quorum threshold).
	// Clients can define one SecurityParams per quorum, and specify multiple quorums.
	// The disperser will ensure that the encoded blobs for each quorum are all processed
	// within the same batch.
	repeated SecurityParams security_params = 2;
}

message DisperseBlobReply {
	// The status of the blob associated with the request_id.
	BlobStatus result = 1;
	// The request ID generated by the disperser.
	// Once a request is accepted (although not processed), a unique request ID will be
	// generated.
	// Two different DisperseBlobRequests (determined by the hash of the DisperseBlobRequest)
	// will have different IDs, and the same DisperseBlobRequest sent repeatedly at different
	// times will also have different IDs.
	// The client should use this ID to query the processing status of the request (via
	// the GetBlobStatus API).
	bytes request_id = 2;
}

// BlobStatusRequest is used to query the status of a blob.
message BlobStatusRequest {
	bytes request_id = 1;
}

message BlobStatusReply {
	// The status of the blob.
	BlobStatus status = 1;
	// The blob info needed for clients to confirm the blob against the EigenDA contracts.
	BlobInfo info = 2;
}

// RetrieveBlobRequest contains parameters to retrieve the blob.
message RetrieveBlobRequest {
	bytes batch_header_hash = 1;
	uint32 blob_index = 2;
}

// RetrieveBlobReply contains the retrieved blob data
message RetrieveBlobReply {
	bytes data = 1;
}

// Data Types

// SecurityParams contains the security parameters for a given quorum.
message SecurityParams {
	// The ID of the quorum.
	// The quorum must be already registered on EigenLayer. The ID must be
	// in range [0, 255].
	uint32 quorum_id = 1;
	// The max percentage of stake within the quorum that can be held by or delegated
	// to adversarial operators.
	//
	// Clients use this to customize the trust assumption (safety).
	//
	// Requires: 1 <= adversary_threshold < 100
	uint32 adversary_threshold = 2;
	// The min percentage of stake that must attest in order to consider
	// the dispersal is successful.
	//
	// Clients use this to customize liveness requirement. The higher this number,
	// the more operators may need to be up for attesting the blob, so the chance
	// the dispersal request to fail may be higher (liveness for dispersal).
	//
	// Requires:
	//     1 <= quorum_threshld <= 100
	//     quorum_threshld > adversary_threshold + 10.
	//
	// Note: The adversary_threshold and quorum_threshold will directly influence the
	// cost of encoding for the blob to be dispersed, roughly by a factor of
	// 100 / (quorum_threshold - adversary_threshold). See the spec for more details:
	// https://github.com/Layr-Labs/eigenda/blob/master/docs/spec/protocol-modules/storage/overview.md
	// Currently it's required that the difference must be at least 10.
	uint32 quorum_threshold = 3;
}

enum BlobStatus {
	UNKNOWN = 0;

	// Intermediate states

	// PROCESSING means that the blob is currently being processed by the disperser
	PROCESSING = 1;
	// CONFIRMED means that the blob has been dispersed to DA Nodes and the dispersed
	// batch containing the blob has been confirmed onchain
	CONFIRMED = 2;

	// Terminal states

	// FAILED means that the blob has failed permanently (for reasons other than insufficient
	// signatures, which is a separate state)
	FAILED = 3;
	// FINALIZED means that the block containing the blob's confirmation transaction has been finalized on Ethereum
	FINALIZED = 4;
	// INSUFFICIENT_SIGNATURES means that the quorum threshold for the blob was not met
	// for at least one quorum.
	INSUFFICIENT_SIGNATURES = 5;
}

// Types below correspond to the types necessary to verify a blob
// https://github.com/Layr-Labs/eigenda/blob/master/contracts/src/libraries/EigenDABlobUtils.sol#L29

// BlobInfo contains information needed to confirm the blob against the EigenDA contracts
message BlobInfo {
	BlobHeader blob_header = 1;
	BlobVerificationProof blob_verification_proof = 2;
}

message BlobHeader {
	// KZG commitment to the blob.
	bytes commitment = 1;
	// The length of the blob in symbols (each symbol is 31 bytes).
	uint32 data_length = 2;
	// The params of the quorums that this blob participates in.
	repeated BlobQuorumParam blob_quorum_params = 3;
}

message BlobQuorumParam {
	// The ID of the quorum.
	uint32 quorum_number = 1;
	// Same as SecurityParams.adversary_threshold.
	uint32 adversary_threshold_percentage = 2;
	// Same as SecurityParams.quorum_threshold.
	uint32 quorum_threshold_percentage = 3;
	// The length of each chunk.
	uint32 chunk_length = 4;
}

message BlobVerificationProof {
	// batch_id is an incremental ID assigned to a batch by EigenDAServiceManager
	uint32 batch_id = 1;
	// The index of the blob in the batch (which is logically an ordered list of blobs).
	uint32 blob_index = 2;
	BatchMetadata batch_metadata = 3;
	// inclusion_proof is a merkle proof for a blob header's inclusion in a batch
	bytes inclusion_proof = 4;
	// indexes of quorums in BatchHeader.quorum_numbers that match the quorums in BlobHeader.blob_quorum_params
	// Ex. BlobHeader.blob_quorum_params = [
	// 	{
	//		quorum_number = 0,
	// 		...
	// 	},
	// 	{
	//		quorum_number = 3,
	// 		...
	// 	},
	// 	{
	//		quorum_number = 5,
	// 		...
	// 	},
	// ]
	// BatchHeader.quorum_numbers = [0, 5, 3] => 0x000503
	// Then, quorum_indexes = [0, 2, 1] => 0x000201
	bytes quorum_indexes = 5;
}

message BatchMetadata {
	BatchHeader batch_header = 1;
	// The hash of all public keys of the operators that did not sign the batch.
	bytes signatory_record_hash = 2;
	// The fee payment paid by users for dispersing this batch. It's the bytes
	// representation of a big.Int value.
	bytes fee = 3;
	// The Ethereum block number at which the batch is confirmed onchain.
	uint32 confirmation_block_number = 4;
	// This is the hash of the ReducedBatchHeader defined onchain, see:
	// https://github.com/Layr-Labs/eigenda/blob/master/contracts/src/interfaces/IEigenDAServiceManager.sol#L43
	// The is the message that the operators will sign their signatures on.
	bytes batch_header_hash = 5;
}

message BatchHeader {
	// The root of the merkle tree with the hashes of blob headers as leaves.
	bytes batch_root = 1;
	// All quorums associated with blobs in this batch.
	bytes quorum_numbers = 2;
	// The percentage of stake that has signed for this batch.
	// The quorum_signed_percentages[i] is percentage for the quorum_numbers[i].
	bytes quorum_signed_percentages = 3;
	// The Ethereum block number at which the batch was created.
	// The Disperser will encode and disperse the blobs based on the onchain info
	// (e.g. operator stakes) at this block number.
	uint32 reference_block_number = 4;
}
